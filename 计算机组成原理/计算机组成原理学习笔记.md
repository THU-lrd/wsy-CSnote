# 第1章 计算机系统概论

## 1.1 计算机的发展历程

- 计算机发展历程：
    > 第一代计算机——电子管时代。第一台电子数字计算机ENIAC。电子管也称真空管。
   第二代计算机——晶体管时代。
   第三代计算机——中小规模集成电路时代。
   第四代计算机——大规模集成电路时代。
   第五代计算机——超大规模集成电路时代。

- 早期计算机的更新换代主要集中体现在组成计算机基本电路的元器件(电子管、晶体管、集成电路)上。微型计算机的发展很大程度上取决于微处理器的发展，而微处理器的发展又依赖于芯片集成度和处理器主频的提高。
- 摩尔定律：微芯片上集成的晶体管数目每3年翻两番。由于受物理极限的制约，Moore定律不能永远生效。

## 1.2 计算机系统简介

计算机系统由硬件和软件两大部分组成，完整的计算机系统应包括配套的硬件设备和软件系统，软件和硬件在逻辑功能上是等价的。软件又分为系统软件和应用软件，系统软件主要有操作系统(OS)、语言处理程序(如汇编程序、编译程序、解释程序)、服务程序(如诊断程序、调试程序、连接程序)、数据库管理系统(DBMS)、标准程序库、分布式软件系统、网络软件系统等；应用软件有科学计算程序、数据处理程序、过程控制程序、事务管理程序等。

### 计算机硬件

1. 冯·诺依曼计算机的特点(存储程序的思想：将程序送入主存，由计算机逐条执行)：
	- 采用存储程序的原理，基本工作方式是控制流驱动方式
	-   计算机硬件系统由运算器、存储器、控制器、输入设备和输出设备五大部件组成
	-   指令和数据以同等地位存放于存储器内，并可按地址寻访(CPU区分它们的依据是指令周期的不同阶段)
	-   指令和数据均用二进制数表示
	-   指令由操作码和地址码组成。操作码指出操作的类型，地址码指出操作数的地址。
	-   指令在存储器内按顺序存放
	-   机器以运算器为中心

2. 现代计算机以存储器为中心。运算器和控制器合起来统称为中央处理器CPU，输入设备和输出设备简称I/O设备，所以现代计算机由三大部分CPU、I/O设备和主存储器组成，其中==CPU和主存储器==合起来又可称为==主机==，除主机外的其他硬件装置(外存、I/O设备等)统称为外部设备，简称外设。

3. 五大部件

	- 存储器
		
		存储器分为主存储器(主存、内存)和辅助存储器(辅存，外存)，CPU能够直接访问的是主存储器，而辅助存储器中的信息必须调入主存后才能被CPU访问。
		
		>主存主要包含存储体、MAR、MDR以及时序控制逻辑等。存储体由许多存储单元组成，每个存储单元包含若干存储元件(每个存储元件存储一个bit)，所以存储单元可以存储一串二进制代码，称这串代码为存储字，称这串代码的位数为存储字长。MAR是存储器地址寄存器，用来存放欲访问的存储单元的地址，其位数对应存储单元的个数(如MAR为10位，则有$2^{10}$个存储单元)。MDR是存储器数据寄存器，用来存放从存储体某单元取出的代码或者准备往某存储单元存入的代码，其位数与存储字长相等。
		>
		>主存的工作方式是按存储单元的地址进行存取，这种存取方式称为按地址存取方式，即按地址访问存储器(访存)
		>
		> MAR和MDR虽然是存储器的一部分，但现代计算机中MAR和MDR存在于CPU中，除此之外，Cache也存在于CPU中
	
	- 运算器
		
		运算器最少包括3个寄存器(累加器ACC、乘商寄存器MQ、操作数寄存器X)和一个算术逻辑单元(ALU)。运算器内还有程序状态寄存器(PSW)，也称标志寄存器，用于存放ALU运算得到的一些标志信息或处理机的状态信息。
		
		> 加法：ACC存放被加数及和，X存放加数
		> 减法：ACC存放被减数及差，X存放减数
		> 乘法：ACC存放乘积高位，MQ存放乘数及乘积低位，X存放被乘数
		> 除法：ACC存放被除数及余数，MQ存放商，X存放除数
		
	- 控制器
		
		控制器由控制单元(CU)、程序计数器(PC)和指令寄存器(IR)组成。
		
      > PC用来存放当前欲执行指令的地址，它与主存的MAR之间有一条直接通路，且具有自动加1的功能，即可自动形成下一条指令的地址，PC的位数与MAR的位数相同
	   >
	   >IR用来存放当前的指令，IR的内容来自主存的MDR。指令中的操作码OP(IR)送至CU，用来分析指令，指令中的地址码Ad(IR)作为操作数的地址送往MAR，用以取操作数
	   >
	   >CU用来分析当前指令所需完成的操作，并发出各种微操作命令序列，用以控制所有被控对象
	   >
	   >完成一条指令的过程分为取指阶段(PC)、分析阶段(IR)、执行阶段(CU)

	-  输入设备
	-  输出设备

4. 计算机的工作过程
		![[Pasted image 20230326215756.png]]
		![[Pasted image 20230326215822.png]]

### 计算机系统的层次结构

五级计算机系统的层次结构：
> 虚拟机器M4(高级语言机器) 
> 虚拟机器M3(汇编语言机器)
> 虚拟机器M2(操作系统机器)
> 传统机器M1(机器语言机器)
> 微程序机器M0(微指令系统)

注1：将高级语言程序翻译成机器语言程序的软件称为翻译程序，分为以下三类: 
> 汇编程序(汇编器)：将汇编语言程序翻译成机器语言程序
> 解释程序(解释器)：将源程序中的语句按执行顺序逐条翻译成机器指令并立即执行
> 编译程序(编译器)：将高级语言程序翻译成汇编语言程序

注2 ：从源程序到可执行文件的翻译过程如下：

> 预处理阶段：预处理器(cpp)对源程序中以字符#开头的命令进行处理，例如将#include命令后面的.h文件内容插入程序文件。输出结果是一个以.i为扩展名的源文件hello.i
> 
> 编译阶段：编译器(ccl)对预处理后的源程序进行编译，生成一个汇编语言源程序hello.s。汇编语言源程序中的每条语句都以一种文本格式描述了一条低级机器语言指令。
> 
> 汇编阶段：汇编器(as)将hello.s翻译成机器语言指令，把这些指令打包成一个称为可重定位目标文件的hello.o，它是一种二进制文件，因此用文本编辑器打开会显示乱码。
> 
> 链接阶段：链接器(ld)将多个可重定位目标文件和标准库函数合并为一个可执行目标文件，或简称可执行文件。本例中，链接器将hello.o和标准库函数printf所在的可重定位目标模块printf.o合并，生成可执行文件hello。最终生成的可执行文件被保存在磁盘上。

### 计算机组成和计算机体系结构

计算机体系结构是指那些能够被程序员所见到的计算机系统的属性，即概念性的结构与功能特性，比如指令集、数据类型、存储器寻址技术、I/O机理等，大都属于抽象的属性。计算机组成是指如何实现计算机体系结构所体现的属性，它包含了许多对程序员来说是透明的硬件细节，比如如何取指令、分析指令、取操作数、运算、送结果等都属于计算机组成问题。

## 1.3 计算机的性能指标

### 1. 字长

- 某“64位机器”中64指的就是字长，也称机器字长，它是CPU一次能处理数据的位数，通常等于CPU内部用于整数运算的运算器位数和通用寄存器宽度。注意字和字长概念不同，字用来表示被处理信息的单位，用来度量数据类型的宽度，比如x86机器中将一个字定义为16位
- 指令字长是指一个指令字中包含的二进制代码的位数(指令字长一般是存储字长的整数倍)
- 存储字长是指一个存储单元存储的二进制代码的位数

### 2. 数据通路带宽

数据通路带宽是指数据总线一次所能并行传送信息的位数，这里指的是外部数据总线的宽度，与CPU内部的数据总线宽度(内部寄存器的大小)有可能不同。

### 3. 存储容量

$$
存储容量 = 存储单元个数 \times 存储字长
$$
如MAR为16位，可称为$64K$内存，若MDR为32位，表示主存容量为$64K \times 32$位，现代计算机中常以字节数描述容量大小，即为$256KB$。

### 4. 运算速度

- 吞吐量：系统在单位时间内处理请求的数量
	响应时间：从用户向计算机发送一个请求到系统对该请求作出响应并获得所需结果的等待时间
- 主频(CPU时钟频率)：机器内部主时钟的频率，单位为Hz
	CPU时钟周期：主频的倒数(是CPU中最小的时间单位)
- CPI：执行一条指令所需的时钟周期数
- CPU执行时间：运行一个程序所花费的时间
$$CPU执行时间=\frac{CPU时钟周期数}{主频}=\frac{指令条数\times CPI}{主频}$$
- IPS：每秒执行多少条指令，分为kIPS和MIPS
$$IPS=\frac{主频}{平均CPI}$$
- FLOPS：每秒执行多少次浮点运算，分为kFLOPS、MFLOPS、GFLOPS、TFLOPS等
	注意在描述速率、频率时，k、M、G、T分别表示$10^3,10^6,10^9,10^{12}$，而在描述存储容量、文件大小时，K、M、G、T分别表示$2^{10},2^{20},2^{30},2^{40}$ (更大的有P、E、Z)

### 5. 基准程序

基准程序是专门用来进行性能评价的一组程序。

注： 几个专业术语：

> 系列机：具有基本相同的体系结构，使用相同基本指令系统的多个不同型号的计算机组成的一个产品系列
> 
> 兼容：指软件或硬件的通用性
> 
> 软件可移植性：指把使用在某个系列计算机中的软件直接或进行很少的修改就能运行在另一个系列计算机中的可能性
> 
> 固件：将程序固化在ROM中组成的部件称为固件，它是一种具有软件特性的硬件，执行速度快于软件，灵活性优于硬件

# 第2章 计算机的运算方法

## 2.1 无符号数和有符号数

>原码：进行加减运算时比较麻烦，当两个操作数符号不同作加法时，要判断绝对值大小确定符号
>
>补码：由y的补码连同符号位在内，每位取反，末位加1，可以得到-y的补码
>
>反码
>
>移码=偏置值+真值，一般取偏置值为$2^{n−1}$，于是$[x]_{移}=x+2^{n-1}$，注意移码只能表示整数
> - 如果偏置值为$2^{n - 1}$，则移码其实等同于补码的最高位(符号位)取反，所以移码表示中零也是唯一的
> - 如果偏置值为$2^{n - 1}$，则可表示的最小真值的移码为全0，所以用移码可以方便地判断数的大小
> - IEEE中阶码规定用偏置值为$2^{n - 1} - 1$的移码表示

## 2.2 ALU电路

![[Pasted image 20230327165610.png]]

- 一位全加器: 全加器(FA)是最基本的加法单元，有加数$A_i、B_i$与低位传来的进位$C_{i−1}$ 共三个输入，有本位和$S_i$与向高位的进位$C_i$共两个输出。

	> 和表达式：$S_i = A_i\bigoplus B_i \bigoplus C_{i-1}$
	> 进位表达式：$C_i = A_iB_i+(A_i\bigoplus B_i)C_{i - 1}$
	> 称$A_iB_i$为进位产生函数，$A_i\bigoplus B_i$为进位传递函数
	
- 串行进位的并行加法器：n个全加器相连，其最长运算时间主要由进位信号的传递时间决定
- 并行进位的并行加法器：并行加法器中的进位信号同时产生，又称先行进位、跳跃进位
	> 根据逻辑运算可将$C_i$的表达式化作只依赖于$C_0$，而不依赖于其他$C_k$，从而实现先行进位。实现这一逻辑表达式的电路称为先行进位部件(CLA部件)。
	> 但位数越高，$C_i$的逻辑表达式越长。所以对于16位加法器，可以分成4组，组内为4位先行进位，组间串行进位，称之为单级先行进位加法器。也可以采用组内和组间都并行的进位方式，称之为两级先行进位加法器。
	
## 2.3 浮点数

### 1. 浮点数的一般形式

|阶符|阶码的数值部分|数符|尾数的数值部分|
|-|-|-|-|

当运算结果大于浮点数能表示的最大正数时称为正上溢，小于最小负数时称为负上溢，此时机器停止运算，进行中断溢出处理；当运算结果在0至浮点数能表示的最小正数时称为正下溢，在0至浮点数能表示的最大负数时称为负下溢，此时计算机将其当作机器零处理

规格化：
- 基数为2，规格化时，尾数算术左移一位，阶码减一，称为左规；尾数算术右移一位，阶码加一，称为右规(右规一般用于浮点数运算结果出现溢出时，比如双符号位为01或者10)。类似地，若基数为4，规格化时算术左(右)移两位，阶码减(加)一
- 用原码表示的规格化尾数：正数为0.1……的形式，所以最大值为0.11……1，最小值为0.10……0; 负数为1.1……的形式，所以最大值为1.10……0，最小值为1.11……1
	用补码表示的规格化尾数：正数为0.1……的形式，所以最大值为0.11……1，最小值为0.10……0; 负数为1.0……的形式，所以最大值为1.01……1，最小值为1.00……0
	一般来说，基数r越大，可表示的浮点数范围越大，个数越多，但精度反而下降。
- 当一个浮点数尾数为0时，不论阶码为何值；或者阶码等于或小于它所能表示的最小数时，不论其尾数为何值，机器都将该浮点数视作零，称为机器零

### 2. IEEE 754标准

![[Pasted image 20230327171022.png]]
![[Pasted image 20230327171034.png]]
![[Pasted image 20230327171041.png]]

### 3. 强制类型转换

![[Pasted image 20230327171058.png]]

## 2.4 移位运算

逻辑移位(无符号数的移位)：逻辑左移时，高位丢弃，低位添0；逻辑右移时，低位丢弃，高位添0

算术移位(有符号数的移位)：无论正数或负数，符号位始终不变，数值部分进行移位添补。对于正数，无论原码、反码、补码，算术移位时均添补0，而对于负数，添补规则如下：

> 原码：左移右移均添0
> 反码：左移右移均添1
> 补码：左移时低位添0，右移时高位添1

循环移位:

> 带进位标志位CF的循环移位(大循环)：数据位连同进位标志位一起移位
> 不带进位标志位的循环移位(小循环)：数据位中移出的位既移入进位标志位，又移入数据位

![[Pasted image 20230327171324.png]]

## 2.5 加法与减法运算

$$[A+B]_{补} = [A]_{补} + [B]_{补} (\mod 2^{n + 1})$$
$$[A-B]_{补} = [A]_{补} + [-B]_{补} (\mod 2^{n + 1})$$
### 溢出判断

采用一位符号位，注意到只有正数+正数会发生上溢，负数+负数会发生下溢，所以设A的符号位为$A_s$，B的符号位为$B_s$，运算结果的符号位为$S_s$，则溢出逻辑表达式为$V=A_s B_s \overline{S_s}  + \overline{A_s } \overline{B_s } S_s.$ 若V=0，表示无溢出；若V=1，表示有溢出.

采用一位符号位根据数据位的进位情况判断溢出，若符号位的进位$C_s$与最高数位的进位$C_1$相同，则说明没有溢出，否则表示发生溢出。溢出逻辑表达式为$V=C_s\bigoplus C_1$，若V=0，表示无溢出；若V=1，表示有溢出.

采用双符号位。双符号位的补码又称模4补码或变形补码(单符号位补码称为模2补码)，符号位为00表示正数，11表示负数(但在存储时，计算机中只需一个符号位)。采用双符号位补码进行加减运算时，若运算结果的两位符号位相同，表示没有溢出，否则表示溢出，01表示正溢出，10表示负溢出(高位符号位代表真正的符号，低位符号位表示该数现在的符号，比如两个正数相加得到符号位为01，表示理应是一个正数，缺因上溢变成了一个负数)

### 程序状态字寄存器PSW

PSW中有几个标志位可用来区分有符号整数和无符号整数的运算结果

> 零标志ZF：运算结果为0则ZF=1，否则ZF=0. 不管对于无符号数还是有符号数运算，ZF都有意义
> 溢出标志OF：有符号整数运算发生溢出时OF=1，否则为0. 对于无符号数运算，OF没有意义
> 符号标志SF：表示运算结果的符号，结果为负则SF=1，否则为0. 对于无符号数运算，SF没有意义
> 进/借位标志CF：表示无符号整数运算时的进位/借位，判断是否发生溢出，加法时CF=1表示结果溢出(有进位)，减法时CF=1表示不够减(有借位)，而CF=0则表示没有进位和借位. 对于有符号数运算，CF没有意义

### 符号扩展

例如将4位二进制数扩展为8位二进制数

正整数：0 101 扩展为0 0000101
正小数：0 101 扩展为0 1010000

负整数：
> 原码：1 101 扩展为1 0000101
> 反码：1 010 扩展为1 1111010
> 补码：1 011 扩展为1 1111011

负小数：
> 原码：1 101扩展为1 1010000
> 反码：1 010扩展为1 0101111
> 补码：1 011扩展为1 0110000

## 2.6 乘法运算

![[Pasted image 20230327172637.png]]
![[Pasted image 20230327172653.png]]
## 2.7 除法运算

![[Pasted image 20230327172722.png]]
![[Pasted image 20230327172729.png]]
![[Pasted image 20230327172736.png]]

## 2.8 数据的存储和排列

大端方式和小端方式：
> 大端方式按从最高有效字节到最低有效字节的顺序存储数据，即最高有效字节(MSB)放在低地址
> 小端方式按从最低有效字节到最高有效字节的顺序存储数据，即最低有效字节(LSB)放在低地址

边界对齐和边界不对齐方式：如果数据按边界对齐方式存储，则其存放的起始地址必须能被自身长度整除
![[Pasted image 20230327172907.png]]

## 2.9 浮点数的加减运算

![[Pasted image 20230327172935.png]]
## 2.10 校验码

### 奇偶校验码

![[Pasted image 20230327173015.png]]
![[Pasted image 20230327173021.png]]

偶校验的硬件实现：各信息位进行异或运算，得到的结果即为偶校验位

### 海明校验码

![[Pasted image 20230327173041.png]]
![[Pasted image 20230327173046.png]]
![[Pasted image 20230327173054.png|300]]

- 有时，海明码校验位的位置设计可能相反，但做法类似：
![[Pasted image 20230327173222.png|500]]
- 海明码拥有纠1位错，检2位错的能力(但检2位错需要加上全校验位)：
![[Pasted image 20230327173249.png]]

### 循环冗余校验码(CRC码)

![[Pasted image 20230327173313.png]]
![[Pasted image 20230327173322.png|400]]
部分余数最高位为1则商1，否则商0(即模2除)；部分余数作减法采用模2减(等同于模2加)

![[Pasted image 20230327173400.png]]
![[Pasted image 20230327173406.png]]
![[Pasted image 20230327173413.png]]

# 第3章 存储器概述

